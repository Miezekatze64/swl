/* SWL STANDARD LIBRARY */
// used intrinsics
intrinsic syscall      as syscall0(int index)                           -> int;
intrinsic syscall      as syscall1(int index, int val)                  -> int;
intrinsic syscall      as syscall2(int index, int val, int val2)        -> int;
intrinsic syscall      as syscall3(int index, int val, int val2, int val3)
      -> int;
intrinsic syscall      as syscall4(int index, int val, int val2, int val3,
    int val4)  -> int;
intrinsic str_to_ptr   as arr2addr(string str)                          -> int;
intrinsic dereference  as arrlen([unchecked] str)                       -> int;
intrinsic convert      as ptr2arr(int ptr)                       -> [unchecked];
intrinsic convert      as __unsafe_convert(unchecked i)           -> unchecked;

intrinsic set_ptr      as set_ptr(unchecked* ptr, int val);
intrinsic set_ptr      as set_addr(int ptr, int val);

intrinsic get_args     as __get_args()                               -> [char*];

// the default string type (an array of characters)
// strings are fixed-sized arrays and so immutable
// member-functions always return a new instance
alias string = [char];

/** ARGUMENTS **/

// calculates the length of a null-terminated, c-like string
// -----
// args:
//   ptr <- the pointer to the string
// returns: the length
func cstrlen(char *ptr) -> int {
    int i    = 0;
    while (true) {
        bool* _ptr = __unsafe_convert(__unsafe_convert(ptr) + i);
        if (!(deref _ptr)) {
            break;
        }
        i += 1;
    }
    <- i;
}

// converts a null-terminated, c-like string to a char array
// --------
// args:
//   cstr <- the pointer to the string
// returns: the char array
func cstr_to_str(char *cstr) -> string {
    string str = alloc_array(cstrlen(cstr));
    int i = 0;
    while (i < cstrlen(cstr)) {
        char* _ptr = __unsafe_convert(__unsafe_convert(cstr) + i);
        char c = deref _ptr;
        str[i] = c;
        i += 1;
    }
    <- str;
}

func to_cstr(string self) -> char* from string {
    int ptr = _malloc(self.len() + 1);
    int i = 0;

    while (i < self.len()) {
        set_addr(ptr+i, __unsafe_convert(self[i]));
        i += 1;
    }
    set_addr(ptr+self.len(), 0);
    <- __unsafe_convert(ptr);
}

// returns the program's arguments as a char* array
// -----
// returns: the args
func args() -> [char*] {
    [char*] _args = __get_args();
    <- _args;
}

// returns the program's environment as a char* array
// -----
// returns: the environment
func env() -> [char*] {
    [char*] _args = __get_args();
    int argc = arrlen(_args);
    int i = 0;
    
    while (true) {
        char *ptr = _args[i + argc + 1];
        int iptr  = __unsafe_convert(ptr);
        if (iptr == 0) {
            break;
        }
        i += 1;
    }

    int envc = i;
    [char*] envp = alloc_array(envc * (8 + 8));
    int i  = 0;
    while (i < envc) {
        char *env = _args[i + argc + 1]; 
        envp[i] = env;
        i += 1;
    }
    <- envp;
}

// returns the program's environment as a char* pointer
// -----
// returns: the environment
func envp() -> char* * {
    <- __unsafe_convert(__unsafe_convert(env()) + 8);
}
    
/** MEMORY UTILS **/

// calls the brk (break) system call, to change the current program break (start of heap) to given location
// -------
// args:
//   val <- the next break location (pointer)
// returns:
//   if > 0: the number of bytes the break moved.
//   if 0: the current program break
func _brk(int val) -> int {
    <- syscall1(12, val);
}

// moves the current program's break (start of heap) a given number of bytes
// -------
// args:
//   inc <- the number of bytes to increment
// returns:
//   the new loctaion of the break
func _sbrk(int inc) -> int {
    int newbrk;
    int oldbrk = 0;
    int curbrk = 0;
    
    if (oldbrk == 0) {
        curbrk = _brk(0);
        oldbrk = curbrk;
    }

    if (inc == 0) {
        <- curbrk;
    }
    
    newbrk = curbrk + inc;
    
    if (_brk(newbrk) == curbrk) {
        <- (-1);
    }
    
    oldbrk = curbrk;
    curbrk = newbrk;
    <- oldbrk;
}

// fields used by _malloc and _free
// _m_heap_start:
//   contains the current start of the heap (program break)
// _m_location:
//   contains the last used index of the tcache
// _m_tcache:
//   contains current allocated (and freed + blocked) blocks of the malloc() and free() functions
int    _m_heap_start = 0;
int    _m_location = 0;
[m_struct]  _m_tcache;

// the structure of the tcache (one allocated or blocked block)
// ptr:
//    the memory location of the block
// size:
//    the size (in bytes) of the block
// is_block:
//    true if block, false if hole
struct m_struct {
    int ptr;
    int size;
    bool is_block;
}


// allocates given number of bytes
// ------
// args:
//   size <- the number of bytes to allocate
// returns: the address of the allocated space
func _malloc(int size) -> int {
    if (_m_heap_start == 0) {
        _m_heap_start = _sbrk(0);
        _m_tcache     = ptr2arr(_sbrk(1000 * (8 + 8 + 1)));
    }

    int i = 0;
    while (i < _m_location) {
        m_struct index = _m_tcache[i];
        if (!index.is_block && index.size >= size) {
            _m_tcache[0].is_block = true;
            <- index.ptr;
        }
        i += 1;
    }
    
    int ptr = _sbrk(size);
    int current = ptr + size;

    _m_tcache[_m_location] = m_struct {
        ptr: ptr;
        size: size;
        is_block: true;
    };

    _m_location += 1;
    
    <- ptr;
}

// frees an earlier allocated block
// ------
// args:
//   ptr <- the address of the block to free
func _free(int ptr) {
    int i = 0;
    while (i < _m_location) {
        m_struct index = _m_tcache[i];
        if (ptr == index.ptr && index.is_block) {
            // free it
            _m_tcache[i].is_block = false;
            // test for merge left
            if (i > 0) {
                if (!_m_tcache[i - 1].is_block) {
                    _m_tcache[i - 1].size = _m_tcache[i - 1].size + _m_tcache[i].size;
                }
            }

            if (i < _m_location - 1) {
                if (!_m_tcache[i + 1].is_block) {
                    _m_tcache[i].size = _m_tcache[i + 1].size + _m_tcache[i].size;
                }
            }

            if (i == _m_location - 1) {
                // decrement heap space
                _sbrk(-_m_tcache[i].size);
            }
            <-;
        }
        i += 1;
    }

    print("free: double free\n");
}

// allocates an array with a given number of bytes on the heap
// ------
// args:
//   size <- the number of bytes to allocate
// returns: an array at the newly allocated space
func alloc_array(int size) -> [unchecked] {
    int ptr     = _malloc(8+size);
    set_addr(ptr, size);
    [int] array = ptr2arr(ptr);
    <- array;
}

// frees an earlier allocated array
// ------
// args:
//   a <- the array to free
func free_array([unchecked] a) {
    _free(__unsafe_convert(a));
}

// copies the contents of string b to string a (without overflow)
// ------
// args:
//   a <- the destination string
//   b <- the source string
func strcpy(string a, string b) {
    int i = 0;
    int len = min(arrlen(a), arrlen(b));
    while (i < len) {
        a[i] = b[i];
        i += 1;
    }
}

/** SYSCALL WRAPPER FUNCTIONS (LINUX x86_64) **/

// reads a given number of bytes from a given file descriptor
// ------
// args:
//   fd     <- the file descriptor to read from
//   buf    <- the buffer to read into
//   nbytes <- the number of bytes to read
// returns: the number of bytes read
func read(int fd, int buf, int nbytes) -> int {
    <- syscall3(0, fd, buf, nbytes);
}

// writes a given number of bytes to a given file descriptor
// ------
// args:
//   fd     <- the file descriptor to write to
//   buf    <- the buffer to write from
//   nbytes <- the number of bytes to write
// returns: the number of bytes written
func write(int fd, int buf, int nbytes) -> int {
    <- syscall3(1, fd, buf, nbytes);
}

// opens a file with a given path, mode, and flags
// ------
// args:
//   path <- the path to the file to open
//   mode <- the mode to open the file with
//   flags <- the flags to open the file with
// returns: the file descriptor of the opened file
func open(string path, int flags, int mode) -> int {
    <- syscall3(2, arr2addr(path), flags, mode);
}

// closes a given file descriptor
// ------
// args:
//   fd <- the file descriptor to close   
func close(int fd) {
    syscall1(3, fd);
}

// sets the program break to a given address
// ------
// args:
//   addr <- the address to set the program break to
func brk(int addr) -> int {
    <- syscall1(12, addr);
}

// forks a new process
// ------
// args:
//   returns: the pid of the new process
func fork() -> int {
    <- syscall0(57);
}

// exits the current process
// ------
// args:
//   status <- the status to exit with
func exit(int status) {
    syscall1(60, status);
}


/** IO UTILS **/

// reads contents from stdin in a given array buffer, until it is full
// ------
// args:
//   buf <- the buffer
func input([char] buf) -> int {
    <- read(0, arr2addr(buf), arrlen(buf));
}

// prints a given string to stdout
// ------
// args:
//   str <- the string to print
func print([char] str) {
    write(1, arr2addr(str), arrlen(str));
}

// prints a given string to stderr
// ------
// args:
//   str <- the string to print
func eprint([char] str) {
    write(2, arr2addr(str), arrlen(str));
}

// prints a given string to stdout, followed by a line feed
// ------
// args:
//   str <- the string to print
func println([char] str) {
    print(str);
    print("\n");
}

// prints a given string to stderr, followed by a line feed
// ------
// args:
//   str <- the string to print
func eprintln([char] str) {
    print(str);
    print("\n");
}

// replaces the current process with the given process
// -----
// args:
//   filename <- the filename of the process
//   argv     <- args of the process
//   envp     <- environment of the process
func execve(string filename, [char*] argv, [char*] envp) {
    syscall3(59, __unsafe_convert(filename.to_cstr()), __unsafe_convert(argv) + 8, __unsafe_convert(envp) + 8);
}

// runs a given command
// -----
// args:
//   command <- the command
func system(string command) {
    [char*] args = alloc_array(8*4);
    args[0] = "/usr/bin/sh".to_cstr();
    args[1] = "-c".to_cstr();
    args[2] = command.to_cstr();
    args[3] = __unsafe_convert(0);

    int pid = fork();
    if (pid == 0) {
        execve("/usr/bin/sh", args, env());
        exit(0);
    }
    while (true) {
       int ret = syscall4(61, pid, 0, 0, 0);
       if (ret <= 0) {
           break;
       }
       sleep(10);
    }
}

struct timespec {
    int _secs;
    int nanos;
}

// sleeps a given amount of milliseconds
// -----
// args:
//   millis <- the time
func sleep(int millis) {
    timespec time = timespec {
        _secs: millis / 1000;
        nanos: (millis % 1000) * 1000000;
    };
    syscall2(35, __unsafe_convert(ref time),  0);
}

/** STRING UTILS **/

// converts the char to ASCII char code
// -------
// returns: the char code
func char_code(char self) -> int from char {
    <- __unsafe_convert(self);
}

// convert given char code (ASCII) to a character
// -------
// returns: the char
func to_char(int self) -> char from int {
    <- __unsafe_convert(self);
}

// func format(string str)

// converts a single digit to (0-9) to corresponding ASCII character ('0'-'9')
// -------
// args:
//   i <- the digit
// returns: the character
func digit_to_ascii(int i) -> char {
    <- ('0'.char_code() + i).to_char();
}
    
// converts an integer to its string representation
// -------
// args:
//   i <- the integer
// returns: the string
func itoa(int i) -> string {
    bool negative = false;
    if (i < 0) {
        negative = true;
        i = -i;
    }
    
    int len = 0;
    int num = i;
    while (num >= 10) {
        num /= 10;
        len += 1;
    }

    if (negative) {
        len += 1;
    }

    string result = alloc_array(len + 1);
    int index = len;
    int num = i;
    while (index >= 0) {
        result[index] = digit_to_ascii(num % 10);
        num /= 10;
        index -= 1;
    }

    if (negative) {
        result[0] = '-';
    }
    
    <- result;
}

// converts the integer to a string
// -----
// returns: the string
func to_string(int self) -> string from int {
    <- itoa(self);
}
    
// converts a boolean to a string (true -> "true", false -> "false")
// ------
// args:
//   b <- the boolean
// returns: the strings
func bool_to_string(bool b) -> [char] {
    if (b) {
        <- "true";
    }
    <- "false";
}

// returns the length of the string
// ------
// returns: the length
func len(string self) -> int from string {
    <- arrlen(self);
}

// appends a given character to a string and returns the new string
// ------
// args:
//   c <- the char to append
// returns: the new string
func append(string self, char c) -> string from string {
    string new = alloc_array(self.len() + 1);
    strcpy(new, self);
    int len = self.len();
    new[len] = c;
    <- new;
}

// checks if string starts with given character
// ------
// args:
//   c <- the character
// returns: true, if string starts with c, false otherwise
func startsWith(string self, char c) -> bool from string {
    if (self.len() < 1) {
        <- false;
    }
    <- self[0] == c;
}

// checks if string ends with given character
// ------
// args:
//   c <- the character
// returns: true, if string ends with c, false otherwise
func endsWith(string self, char c) -> bool from string {
    if (self.len() < 1) {
        <- false;
    }
    <- self[self.len() - 1] == c;
}

    
/** MATH UTILS **/
    
// returns the smaller of two numbers
// ------
// args:
//   a <- the first number
//   b <- the second number
// returns: the smaller number
func min(int a, int b) -> int {
    if (a < b) {
        <- a;
    }
    <- b;
}

// returns the bigger of two numbers
// ------
// args:
//   a <- the first number
//   b <- the second number
// returns: the bigger number
func max(int a, int b) -> int {
    if (a > b) {
        <- a;
    }
    <- b;
}

// asserts a given condition is true and panics if not
// @TODO: replace this with a macro
// -----
// args:
//   cond <- the condition to be checked
//   msg  <- the message to display
func assert(bool cond, string msg) {
    if (!cond) {
        eprint("Assertion failed: ");
        eprintln(msg);
        exit(1);
    }
}
