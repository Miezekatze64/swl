/* SWL STANDARD LIBRARY */
// used intrinsics
intrinsic syscall      as syscall1(int index, int val) -> int;
intrinsic syscall      as syscall3(int index, int val, int val2, int val3);
intrinsic str_to_ptr   as arr2addr(string str) -> int;
intrinsic dereference  as arrlen(string str)   -> int;

intrinsic convert      as ptr2arr(int ptr) -> [unchecked]
intrinsic convert      as __unsafe_convert(unchecked i)     -> unchecked;

intrinsic set_ptr      as set_ptr(unchecked* ptr, int val);
intrinsic set_ptr      as set_addr(int ptr, int val);

// the default string type (an array of characters)
// strings are fixed-sized arrays and so immutable
// member-functions always return a new instance
alias string = [char];

/** MEMORY UTILS **/

// calls the brk (break) system call, to change the current program break (start of heap) to given location
// -------
// args:
//   val <- the next break location (pointer)
// returns:
//   if > 0: the number of bytes the break moved.
//   if 0: the current program break
func _brk(int val) -> int {
    <- syscall1(12, val);
}

// moves the current program's break (start of heap) a given number of bytes
// -------
// args:
//   inc <- the number of bytes to increment
// returns:
//   the new loctaion of the break
func _sbrk(int inc) -> int {
    int newbrk;
    int oldbrk = 0;
    int curbrk = 0;
    
    if (oldbrk == 0) {
        curbrk = _brk(0);
        oldbrk = curbrk;
    }

    if (inc == 0) {
        <- curbrk;
    }
    
    newbrk = curbrk + inc;
    
    if (_brk(newbrk) == curbrk) {
        <- (-1);
    }
    
    oldbrk = curbrk;
    curbrk = newbrk;
    <- oldbrk;
}

// fields used by _malloc and _free
// _m_heap_start:
//   contains the current start of the heap (program break)
// _m_location:
//   contains the last used index of the tcache
// _m_tcache:
//   contains current allocated (and freed + blocked) blocks of the malloc() and free() functions
int    _m_heap_start = 0;
int    _m_location = 0;
[_m_struct]  _m_tcache;

// the structure of the tcache (one allocated or blocked block)
// ptr:
//    the memory location of the block
// size:
//    the size (in bytes) of the block
// is_block:
//    true if block, false if hole
struct _m_struct {
    int ptr;
    int size;
    bool is_block;
}


// allocates given number of bytes
// ------
// args:
//   size <- the number of bytes to allocate
// returns: the address of the allocated space
func _malloc(int size) -> int {
    if (_m_heap_start == 0) {
        _m_heap_start = _sbrk(0);
        _m_tcache     = ptr2arr(_sbrk(1000 * (8 + 8 + 1)));
    }

    int i = 0;
    while (i < _m_location) {
        _m_struct index = _m_tcache[i];
        if (!index.is_block && index.size >= size) {
            _m_tcache[0].is_block = true;
            <- index.ptr;
        }
        i += 1;
    }
    
    int ptr = _sbrk(size);
    int current = ptr + size;

    _m_tcache[_m_location] = _m_struct {
        ptr: ptr;
        size: size;
        is_block: true;
    };

    _m_location += 1;
    
    <- ptr;
}

// frees an earlier allocated block
// ------
// args:
//   ptr <- the address of the block to free
func _free(int ptr) {
    int i = 0;
    while (i < _m_location) {
        _m_struct index = _m_tcache[i];
        if (ptr == index.ptr && index.is_block) {
            // free it
            _m_tcache[i].is_block = false;
            // test for merge left
            if (i > 0) {
                if (!_m_tcache[i - 1].is_block) {
                    _m_tcache[i - 1].size = _m_tcache[i - 1].size + _m_tcache[i].size;
                }
            }

            if (i < _m_location - 1) {
                if (!_m_tcache[i + 1].is_block) {
                    _m_tcache[i].size = _m_tcache[i + 1].size + _m_tcache[i].size;
                }
            }

            if (i == _m_location - 1) {
                // decrement heap space
                _sbrk(-_m_tcache[i].size);
            }
            <-;
        }
        i += 1;
    }

    print("free: double free\n");
}

// allocates an array with a given number of bytes on the heap
// ------
// args:
//   size <- the number of bytes to allocate
// returns: an array at the newly allocated space
func alloc_array(int size) -> [unchecked] {
    int ptr     = _malloc(size);
    set_addr(ptr, size);
    [int] array = ptr2arr(ptr);
    <- array;
}

// frees an earlier allocated array
// ------
// args:
//   a <- the array to free
func free_array([unchecked] a) {
    _free(__unsafe_convert(a));
}

// copies the contents of string b to string a (without overflow)
// ------
// args:
//   a <- the destination string
//   b <- the source string
func strcpy(string a, string b) {
    int i = 0;
    int len = min(arrlen(a), arrlen(b));
    while (i < len) {
        a[i] = b[i];
        i += 1;
    }
}

/** IO UTILS **/
    
// exits the program with given exit code
// ------
// args:
//   code <- the exit code
func exit(int code) {
    syscall1(60, code);
}

// reads contents from stdin in a given array buffer, until it is full
// ------
// args:
//   buf <- the buffer
func read([char] buf) {
    syscall3(0, 0, arr2addr(buf), arrlen(buf));
}

// prints a given string to stdout
// ------
// args:
//   str <- the string to print
func print([char] str) {
    syscall3(1, 1, arr2addr(str), arrlen(str));
}

func println([char] str) {
    print(str.append('\n'));
}

/** STRING UTILS **/

// TODO: finish
func digit_to_ascii(int i) -> char {
    <- 'a';
}
    
// TODO: finish
func itoa(int i) -> string {
    int len = 1;
    int num = i;
    while (num >= 10) {
        num /= 10;
        len += 1;
    }

    string result = alloc_array(len + 1);
    
    int index = len - 1;
    int num = i;
    while (index >= 0) {
        result[index] = digit_to_ascii(num % 10);
        num /= 10;
        index -= 1;
    }
    
    <- result;
}
    
// converts a boolean to a string (true -> "true", false -> "false")
// ------
// args:
//   b <- the boolean
// returns: the strings
func bool_to_string(bool b) -> [char] {
    if (b) {
        <- "true";
    }
    <- "false";
}

// returns the length of the string
// ------
// returns: the length
func len(string self) -> int from string {
    <- arrlen(self);
}

// appends a given character to a string and returns the new string
// ------
// args:
//   c <- the char to append
// returns: the new string
func append(string self, char c) -> string from string {
    string new = alloc_array(self.len() + 1);
    strcpy(new, self);
    int len = self.len();
    new[len] = c;
    <- new;
}

// checks if string starts with given character
// ------
// args:
//   c <- the character
// returns: true, if string starts with c, false otherwise
func startsWith(string self, char c) -> bool from string {
    if (self.len() < 1) {
        <- false;
    }
    <- self[0] == c;
}

// checks if string ends with given character
// ------
// args:
//   c <- the character
// returns: true, if string ends with c, false otherwise
func endsWith(string self, char c) -> bool from string {
    if (self.len() < 1) {
        <- false;
    }
    <- self[self.len() - 1] == c;
}

    
/** MATH UTILS **/
    
// returns the smaller of two numbers
// ------
// args:
//   a <- the first number
//   b <- the second number
// returns: the smaller number
func min(int a, int b) -> int {
    if (a < b) {
        <- a;
    }
    <- b;
}

// returns the bigger of two numbers
// ------
// args:
//   a <- the first number
//   b <- the second number
// returns: the bigger number
func max(int a, int b) -> int {
    if (a > b) {
        <- a;
    }
    <- b;
}
