/* SWL STANDARD LIBRARY */
// used intrinsics
intrinsic syscall      as syscall1(int index, int val) -> int;
intrinsic syscall      as syscall3(int index, int val, int val2, int val3);
intrinsic str_to_ptr   as arr2addr(string str) -> int;
intrinsic dereference  as arrlen(string str)   -> int;

intrinsic convert      as ptr2arr(int ptr) -> [unchecked]
intrinsic convert      as __unsafe_convert(unchecked i)     -> unchecked;

intrinsic set_ptr      as set_ptr(int ptr, int val);

// the default string type (an array of characters)
alias string = [char];


// calls the brk (break) system call, to change the current program break (start of heap) to given location
// -------
// args:
//   val <- the next break location (pointer)
// returns:
//   if > 0: the number of bytes the break moved.
//   if 0: the current program break
func _brk(int val) -> int {
    <- syscall1(12, val);
}

// moves the current program's break (start of heap) a given number of bytes
// -------
// args:
//   inc <- the number of bytes to increment
// returns:
//   the new loctaion of the break
func _sbrk(int inc) -> int {
    int newbrk;
    int oldbrk = 0;
    int curbrk = 0;
    
    if (oldbrk == 0) {
        curbrk = _brk(0);
        oldbrk = curbrk;
    }

    if (inc == 0) {
        <- curbrk;
    }
    
    newbrk = curbrk + inc;
    
    if (_brk(newbrk) == curbrk) {
        <- (-1);
    }
    
    oldbrk = curbrk;
    curbrk = newbrk;
    <- oldbrk;
}

// fields used by _malloc and _free
// _m_heap_start:
//   contains the current start of the heap (program break)
// _m_location:
//   contains the last used index of the tcache
// _m_tcache:
//   contains current allocated (and freed + blocked) blocks of the malloc() and free() functions
int    _m_heap_start = 0;
int    _m_location = 0;
[_m_struct]  _m_tcache;

// the structure of the tcache (one allocated or blocked block)
// ptr:
//    the memory location of the block
// size:
//    the size (in bytes) of the block
// is_block:
//    true if block, false if hole
struct _m_struct {
    int ptr;
    int size;
    bool is_block;
}


// allocates given number of bytes
// ------
// args:
//   size <- the number of bytes to allocate
// returns: the address of the allocated space
func _malloc(int size) -> int {
    if (_m_heap_start == 0) {
        _m_heap_start = _sbrk(0);
        _m_tcache     = ptr2arr(_sbrk(1000 * (8 + 8 + 1)));
    }

    int i = 0;
    while (i < _m_location) {
        _m_struct index = _m_tcache[i];
        if (!index.is_block && index.size >= size) {
            _m_tcache[0].is_block = true;
            <- index.ptr;
        }
        i += 1;
    }
    
    int ptr = _sbrk(size);
    int current = ptr + size;

    _m_tcache[_m_location] = _m_struct {
        ptr: ptr;
        size: size;
        is_block: true;
    };

    _m_location += 1;
    
    <- ptr;
}

// frees an earlier allocated block
// ------
// args:
//   ptr <- the address of the block to free
func _free(int ptr) {
    int i = 0;
    while (i < _m_location) {
        _m_struct index = _m_tcache[i];
        if (ptr == index.ptr && index.is_block) {
            // free it
            _m_tcache[i].is_block = false;
            // test for merge left
            if (i > 0) {
                if (!_m_tcache[i - 1].is_block) {
                    print("UNIFY LEFT\n");
                    _m_tcache[i - 1].size = _m_tcache[i - 1].size + _m_tcache[i].size;
                }
            }

            if (i < _m_location - 1) {
                if (!_m_tcache[i + 1].is_block) {
                    print("UNIFY RIGHT\n");
                    _m_tcache[i].size = _m_tcache[i + 1].size + _m_tcache[i].size;
                }
            }

            if (i == _m_location - 1) {
                print("DECREMENT\n");
                // decrement heap space
                _sbrk(-_m_tcache[i].size);
            }
            <-;
        }
        i += 1;
    }

    print("free: double free\n");
}

// allocates an array with a given number of bytes on the heap
// ------
// args:
//   size <- the number of bytes to allocate
// returns: an array at the newly allocated space
func alloc_array(int size) -> [unchecked] {
    int ptr     = _malloc(size);
    set_ptr(ptr, size);
    [int] array = ptr2arr(ptr);
    <- array;
}

// frees an earlier allocated array
// ------
// args:
//   a <- the array to free
func free_array([unchecked] a) {
    _free(__unsafe_convert(a));
}

// copies the contents of string b to string a (without overflow)
// ------
// args:
//   a <- the destination string
//   b <- the source string
func strcpy(string a, string b) {
    int i = 0;
    int len = min(arrlen(a), arrlen(b));
    while (i < len) {
        a[i] = b[i];
        i += 1;
    }
}

// exits the program with given exit code
// ------
// args:
//   code <- the exit code
func exit(int code) {
    syscall1(60, code);
}

// reads contents from stdin in a given array buffer, until it is full
// ------
// args:
//   buf <- the buffer
func read([char] buf) {
    syscall3(0, 0, arr2addr(buf), arrlen(buf));
}

// prints a given string to stdout
// ------
// args:
//   str <- the string to print
func print([char] str) {
    syscall3(1, 1, arr2addr(str), arrlen(str));
}

// converts a boolean to a string (true -> "true", false -> "false")
// ------
// args:
//   b <- the boolean
// returns: the strings
func bool_to_string(bool b) -> [char] {
    if (b) {
        <- "true";
    }
    <- "false";
}

// returns the length of the string
// ------
// returns: the length
func len(string self) -> int from string {
    <- arrlen(self);
}

// returns the smaller of two numbers
// ------
// args:
//   a <- the first number
//   b <- the second number
// returns: the smaller number
func min(int a, int b) -> int {
    if (a < b) {
        <- a;
    }
    <- b;
}

// returns the bigger of two numbers
// ------
// args:
//   a <- the first number
//   b <- the second number
// returns: the bigger number
func max(int a, int b) {
    if (a > b) {
        <- a;
    }
    <- b;
}



